#!/usr/bin/env python
# Copyright (c) 2012 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# A simple native messaging host. Shows a tkinter dialog with incoming messages
# that also allows to send message back to the webapp.

import struct
import sys
import threading
import queue
from tkinter import *
import tkinter
import subprocess
import json
import time


# On Windows, the default I/O mode is O_TEXT. Set this to O_BINARY
# to avoid unwanted modifications of the input/output streams.
if sys.platform == "win32":
  import os, msvcrt
  msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
  msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)

preferences = {}

def load_preferences():
  with open('prefs.json', 'r') as file:
    preferences = json.load(file)

def save_preferences():
  with open('prefs.json', 'r') as file:
    json.dump(preferences, file, indent=2)

# Helper function that sends a message to the webapp.
def send_message(message):
  # Write message size.
  encoded_content = message.encode("utf-8")
  encoded_length = struct.pack('=I', len(encoded_content))
  # Write the message itself.
  sys.stdout.buffer.write(encoded_length)
  sys.stdout.buffer.write(struct.pack(str(len(encoded_content))+"s",encoded_content))
  sys.stdout.buffer.flush()

def launch_stream(url, quality):
  process = subprocess.Popen(['streamlink', url, quality],
    stdout=subprocess.PIPE, 
    universal_newlines=True)
  stdout, stderr = process.communicate()
  stdout, stderr

# Thread that reads messages from the webapp.
def read_thread_func(aq):
  while 1:
    # Read the message length (first 4 bytes).
    text_length_bytes = sys.stdin.buffer.read(4)

    if len(text_length_bytes) == 0:
      if aq:
        aq.put(None)
      sys.exit(0)

    # Unpack message length as 4 byte integer.
    text_length = struct.unpack('=I', text_length_bytes)[0]

    # Read the text (JSON object) of the message.
    text = sys.stdin.buffer.read(text_length).decode('utf-8')

    if aq:
      decodedJson = json.loads(text)
      url = decodedJson['url']
      quality = decodedJson['quality']
      if (url == 'prefs'):
        window = PreferencesWindow()
        window.master.title('Streamlink-Chrome Preferences')
        window.master.geometry("300x700")
        window.master.lift()
        window.master.attributes("-topmost", True)

        window.mainloop()
      elif (quality != ''):
        launch_stream(url, quality)
      else:
        send_message('{"START": "ASD"}')
        
        aq.put(url)
        process = subprocess.Popen(['streamlink', url],
          stdout=subprocess.PIPE, 
          universal_newlines=True)

        response = process.stdout.readlines()
        if (len(response) != 1): # Check that process returned available streams.
          availableStreams = response[1].strip()
          for r in ["Available streams: ", " (best)", " (worst)"]: # Remove useless info.
            availableStreams = availableStreams.replace(r, "")
          streamsList = availableStreams.split(', ')

          # Show quality options popup window
          window = NativeMessagingWindow(url, aq, streamsList)
          window.master.title('Launch Stream')
          window.master.geometry("175x75")
          window.master.lift()
          window.master.attributes("-topmost", True)

          window.mainloop()
    else:
      # In headless mode just send an echo message back.
      send_message('{"echo": %s}' % decodedJson['url'])

if tkinter:
  class NativeMessagingWindow(tkinter.Frame):
    def __init__(self, url, queue, OPTIONS):

      tkinter.Frame.__init__(self)
      self.pack()

      self.url = url

      self.text = tkinter.Text(self)
      self.text.config(state=tkinter.DISABLED, height=10, width=40)

      self.dropdown = tkinter.StringVar(self.master)
      self.dropdown.set(OPTIONS[0]) # Default value for dropdown list

      w = OptionMenu(self.master, self.dropdown, *OPTIONS)
      w.pack(padx=5, pady=10, side=tkinter.LEFT)

      sendButton = tkinter.Button(self.master, text="Launch", command=self.selectQuality)
      sendButton.pack(padx=5, pady=10, side=tkinter.LEFT)

    def selectQuality(self):
      launch_stream(self.url, self.dropdown.get())
      self.master.destroy()
      
  class PreferencesWindow(tkinter.Frame):
    def __init__(self):

      tkinter.Frame.__init__(self)
      self.pack()

      self.text = tkinter.Text(self)
      self.useBestQuality = IntVar(value=preferences['Use Best Quality'])
      # tkinter.Checkbutton(self, text="Use Best Quality", variable=self.useBestQuality).grid(row=0, sticky=W)
      self.text.config(state=tkinter.DISABLED, height=10, width=40)

    def updateUiState(self):
      self.useBestQuality = IntVar(value=preferences['Use Best Quality'])
      self.master.refresh()

def Main():

  load_preferences()

  aq = queue.Queue()


  thread = threading.Thread(target=read_thread_func, args=(aq,))
  thread.daemon = True
  thread.start()


  while True:
    if not aq.empty:
      print("Received %s" % aq.get_nowait)
      
      
    time.sleep(0.1)

  sys.exit(0)


if __name__ == '__main__':
  Main()
