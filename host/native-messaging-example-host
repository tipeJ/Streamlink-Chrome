#!/usr/bin/env python
# Copyright (c) 2012 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# A simple native messaging host. Shows a tkinter dialog with incoming messages
# that also allows to send message back to the webapp.

import struct
import sys
import threading
import queue
from tkinter import *
import tkinter
import subprocess
import json
import time


# On Windows, the default I/O mode is O_TEXT. Set this to O_BINARY
# to avoid unwanted modifications of the input/output streams.
if sys.platform == "win32":
  import os, msvcrt
  msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
  msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)

preferences = {}

def load_preferences():
  global preferences
  with open(os.path.join(sys.path[0], "prefs.json"), 'r') as file:
    preferences = json.loads(file.read())

def save_preferences():
  global preferences
  with open(os.path.join(sys.path[0], "prefs.json"), 'w') as file:
    json.dump(preferences, file)

# Helper function that sends a message to the webapp.
def send_message(message):
  # Write message size.
  encoded_content = message.encode("utf-8")
  encoded_length = struct.pack('=I', len(encoded_content))
  # Write the message itself.
  sys.stdout.buffer.write(encoded_length)
  sys.stdout.buffer.write(struct.pack(str(len(encoded_content))+"s",encoded_content))
  sys.stdout.buffer.flush()

def launch_stream(url, quality):
  process = subprocess.Popen(['streamlink', url, quality],
    stdout=subprocess.PIPE, 
    universal_newlines=True)
  stdout, stderr = process.communicate()
  stdout, stderr

# Thread that reads messages from the webapp.
def read_thread_func(aq):
  while 1:
    # Read the message length (first 4 bytes).
    text_length_bytes = sys.stdin.buffer.read(4)

    if len(text_length_bytes) == 0:
      if aq:
        aq.put(None)
      sys.exit(0)

    # Unpack message length as 4 byte integer.
    text_length = struct.unpack('=I', text_length_bytes)[0]

    # Read the text (JSON object) of the message.
    text = sys.stdin.buffer.read(text_length).decode('utf-8')

    if aq:
      decodedJson = json.loads(text)
      url = decodedJson['url']
      quality = decodedJson['quality']
      if (url == 'prefs'):
        window = PreferencesWindow()
        window.master.title('Preferences')
        window.master.lift()

        window.mainloop()
      elif (quality != ''):
        launch_stream(url, quality)
      elif (preferences['bestQuality']['value']):
        launch_stream(url, "best")
      else:
        send_message('{"START": "ASD"}')
        
        aq.put(url)
        process = subprocess.Popen(['streamlink', url],
          stdout=subprocess.PIPE, 
          universal_newlines=True)

        response = process.stdout.readlines()
        if (len(response) != 1): # Check that process returned available streams.
          availableStreams = response[1].strip()
          for r in ["Available streams: ", " (best)", " (worst)"]: # Remove useless info.
            availableStreams = availableStreams.replace(r, "")
          streamsList = availableStreams.split(', ')

          # Show quality options popup window
          window = LaunchStreamlinkWindow(url, aq, streamsList)
          window.master.title('Launch Stream')
          window.master.geometry("175x75")
          window.master.lift()
          window.master.attributes("-topmost", True)

          window.mainloop()
    else:
      # In headless mode just send an echo message back.
      send_message('{"echo": %s}' % decodedJson['url'])

if tkinter:
  class LaunchStreamlinkWindow(tkinter.Frame):
    def __init__(self, url, queue, OPTIONS):

      tkinter.Frame.__init__(self)
      self.pack()

      self.url = url

      self.text = tkinter.Text(self)
      self.text.config(state=tkinter.DISABLED, height=10, width=40)

      self.dropdown = tkinter.StringVar(self.master)
      self.dropdown.set(OPTIONS[0]) # Default value for dropdown list

      w = OptionMenu(self.master, self.dropdown, *OPTIONS)
      w.pack(padx=5, pady=10, side=tkinter.LEFT)

      launchButton = tkinter.Button(self.master, text="Launch", command=self.selectQuality)
      launchButton.pack(padx=5, pady=10, side=tkinter.LEFT)

    def selectQuality(self):
      thread = threading.Thread(target=launch_stream, args=[self.url, self.dropdown.get()])
      thread.daemon = True
      thread.start()
      time.sleep(0.01) # Sleep for a bit so the window daemon has time to start before destroying the window
      self.master.destroy()
      
  class PreferencesWindow(tkinter.Frame):
    def __init__(self):

      tkinter.Frame.__init__(self)
      self.pack()

      self.useBestQuality = tkinter.BooleanVar(value=preferences['bestQuality']['value'])
      tkinter.Checkbutton(self, text="Use Best Quality", variable=self.useBestQuality).pack(padx=5, pady=10, side=tkinter.LEFT)

      saveButton = tkinter.Button(self.master, text="Cancel", command=self.quit)
      saveButton.pack(padx=5, pady=10, side=tkinter.LEFT)

      saveButton = tkinter.Button(self.master, text="Save Preferences", command=self.savePreferences)
      saveButton.pack(padx=5, pady=10, side=tkinter.RIGHT)

    def savePreferences(self):
      preferences['bestQuality']['value'] = self.useBestQuality.get()
      save_preferences()
      quit()
    
    def quit(self):
      self.master.destroy()

def Main():

  load_preferences()
  
  aq = queue.Queue()

  thread = threading.Thread(target=read_thread_func, args=(aq,))
  thread.daemon = True
  thread.start()

  while True:
    if not aq.empty:
      print("Received %s" % aq.get_nowait)
      
      
    time.sleep(0.1)

  sys.exit(0)


if __name__ == '__main__':
  Main()
